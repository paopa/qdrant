#ifndef BUILDER_HEADER
#define BUILDER_HEADER

#ifndef BUILDER_LAYOUT_SET
#error "BUILDER_LAYOUT_SET not defined"
#endif

#include "common.comp"
#include "vector_storage.comp"
#include "links.comp"
#include "searcher.comp"

layout(set = BUILDER_LAYOUT_SET, binding = 0)
readonly uniform BuilderParams {
    uint generation;
} builder_params;

layout(set = BUILDER_LAYOUT_SET, binding = 1)
buffer RequestsBuffer {
    POINT_ID data[];
} requests;

layout(set = BUILDER_LAYOUT_SET, binding = 2)
buffer GenerationsBuffer {
    uint data[];
} generations;

layout(set = BUILDER_LAYOUT_SET, binding = 3)
readonly buffer LinkPointsBuffer {
    POINT_ID data[];
} link_points;

layout(set = BUILDER_LAYOUT_SET, binding = 4)
readonly buffer UpdateEntryPointsBuffer {
    POINT_ID data[];
} update_entry_points;

#define GENERATION builder_params.generation

void update_entry(uint thread_index) {
    POINT_ID point_id = update_entry_points.data[thread_index];
    ScoredPoint entry_point = {
        requests.data[point_id],
        similarity(point_id, requests.data[point_id])
    };
    requests.data[point_id] = greedy_search(point_id, entry_point).id;
}

void run_request(uint thread_index) {
    searcher_init();

    POINT_ID point_id = link_points.data[thread_index];
    atomicExchange(generations.data[point_id], GENERATION);

    ScoredPoint entry = {
        requests.data[point_id],
        similarity(point_id, requests.data[point_id])
    };

    search(point_id, entry);

    ScoredPoint new_entry = get_nearest(0);
    for (uint i = 1; i < BHEAP(nearest, size); i += 1) {
        ScoredPoint candidate = get_nearest(i);
        if (candidate.score > new_entry.score) {
            new_entry = candidate;
        }
    }
    requests.data[point_id] = new_entry.id;

    uint point_links_count = run_heuristic();
    
    barrier();

    uint i = 0;
    LINKS_SET_SIZE(point_id, point_links_count);
    LINKS_FOREACH(point_id) {
        LINKS_FOREACH_VALUE = get_nearest(i).id;
        i += 1;
    }

    for (i = 0; i < point_links_count; i += 1) {
        POINT_ID other_point_id = GET_LINK(point_id, i);
        uint prev_generation = atomicExchange(generations.data[other_point_id], GENERATION);
        if (prev_generation == GENERATION) {
            continue;
        }

        uint other_point_links_count = LINKS_COUNT(other_point_id);
        if (other_point_links_count < LEVEL_M) {
            GET_LINK(other_point_id, other_point_links_count) = point_id;
            LINKS_SET_SIZE(other_point_id, other_point_links_count + 1);
        } else {
            ScoredPoint other_scored_point = {point_id, similarity(other_point_id, point_id)};
            BHEAP(nearest, push)(other_scored_point);
            LINKS_FOREACH(other_point_id) {
                float candidate_score = similarity(other_point_id, LINKS_FOREACH_VALUE);
                ScoredPoint candidate = {LINKS_FOREACH_VALUE, candidate_score};
                BHEAP(nearest, push)(candidate);
            }
            uint selected_candidates_count = run_heuristic();

            for (uint j = 0; j < selected_candidates_count; j += 1) {
                POINT_ID link = get_nearest(j).id;
                GET_LINK(other_point_id, j) = link;
            }
            LINKS_SET_SIZE(other_point_id, selected_candidates_count);
        }
    }
}

#endif
